options{
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{

    < EL: "\n">
    |
    < AND: "&&" >
    |
    < OR: "||" >
    |
    < LESS: "<" >
    |
    < GREATER: ">" >
    |
    < EQUAL: "==" >
    |
    < NEGATION: "!" >
    |
    < NOT_EQUAL: "!=" >
    |
    < Num: (["0"-"9"]) + >
    |
    < Bool: "true" | "false" >
    |
    < PLUS : "+" >
    |
    < MINUS : "-" >
    |
    < TIMES : "*" >
    |
    < DIV : "/" >
    |
    < LPAR : "(" >
    |
    < RPAR : ")" >
    |
    < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

Exp Start():
{ Exp e; }
{
   e = BoolOp() <EL>  { return e; }
}
Exp BoolOp():
{ Exp e1, e2; }
{
    e1 = CompExp()
    ( <AND> e2 = CompExp() { e1 = new ASTAnd(e1, e2); }
    | <OR> e2 = CompExp() { e1 = new ASTOr(e1, e2); }
    )*
    { return e1; }
}
Exp CompExp():
{ Exp e1, e2; }
{
    e1 = Expr()
    ( <EQUAL> e2 = Expr() { e1 = new ASTEqual(e1, e2); }
    | <LESS> e2 = Expr() { e1 = new ASTLess(e1, e2); }
    | <GREATER> e2 = Expr() { e1 = new ASTGreater(e1, e2); }
    | <NOT_EQUAL> e2 = Expr() { e1 = new ASTNotEqual(e1, e2); }
    )*
    { return e1; }
}
Exp Expr() :
{ Exp e1, e2; }
{
   e1 = Term() 
     [ <PLUS> e2 = Expr() { e1 = new ASTAdd(e1,e2); }
     | <MINUS> e2 = Expr() { e1 = new ASTSub(e1,e2); } ]
     { return e1; }
}

Exp Term() :
{ Exp e1, e2; }
{
     e1 = Fact()
     [ <TIMES> e2 = Term() { e1 = new ASTMult(e1,e2); }
     | <DIV> e2 = Term() { e1 = new ASTDiv(e1,e2); } ]
     { return e1; }
}

Exp Fact() :
{ Token x; Exp e;}
{
  x = <Num>
{
 	return new ASTInt(Integer.parseInt(x.image));
}
|
  x = <Bool>
{
    return new ASTBool(Boolean.parseBoolean(x.image));
}
|
  <MINUS> x = <Num>
{
    return new ASTInt(- (Integer.parseInt(x.image)));
 }
|
  <LPAR> e = BoolOp() <RPAR>
{
 return e;
}
|
  <NEGATION> e = Fact()
{
 return new ASTBoolNegate(e);
}



}





















